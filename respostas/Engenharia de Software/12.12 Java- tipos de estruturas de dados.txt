Item do edital: 12.12 Java- tipos de estruturas de dados   
 
1. Subtópico:
1. Conceitos básicos de estruturas de dados em Java
Assertivas:
1. Em Java, uma estrutura de dados é um meio organizado de armazenamento e manipulação de dados.
2. Em Java, uma das estruturas de dados mais básicas é o array, que permite o armazenamento de múltiplos elementos do mesmo tipo.
3. Em Java, uma lista é uma estrutura de dados que permite o armazenamento de elementos de tipos diferentes e sua manipulação de forma sequencial.
4. Em Java, uma pilha é uma estrutura de dados baseada no princípio LIFO (Last In, First Out) e é utilizada para realizar operações como empilhar e desempilhar elementos.
5. Em Java, uma fila é uma estrutura de dados baseada no princípio FIFO (First In, First Out), sendo utilizada para realizar operações como enfileirar e desenfileirar elementos.
6. Em Java, uma árvore é uma estrutura de dados hierárquica composta por nós, onde cada nó pode ter zero ou mais nós filhos.
7. Em Java, um grafo é uma estrutura de dados que representa um conjunto de vértices ou nós e suas conexões através de arestas.
8. Em Java, um conjunto é uma estrutura de dados que contém apenas elementos únicos, não permitindo duplicidades.
9. Em Java, uma pilha pode ser implementada utilizando-se a classe Stack e métodos como push, pop e peek.
10. Em Java, uma fila pode ser implementada utilizando-se a classe Queue e métodos como offer, poll e peek.

2. Subtópico:
2. Arrays e Matrizes em Java
Assertivas:
1. Arrays em Java são estruturas de dados que armazenam elementos do mesmo tipo em sequência contígua de memória.
2. As matrizes em Java são arrays multidimensionais, ou seja, são arrays que possuem mais de uma dimensão.
3. A declaração de um array em Java envolve a definição do tipo de dados que será armazenado, seguido pelo nome do array e o tamanho desejado, dentro de colchetes.
4. Em Java, o índice de um array começa em zero e vai até o tamanho do array menos um.
5. É possível percorrer um array em Java utilizando laços de repetição, como o for ou o while.
6. O benefício de se utilizar arrays é a capacidade de armazenar e acessar vários elementos do mesmo tipo de forma eficiente.
7. Arrays em Java possuem um tamanho fixo, que é definido no momento da sua criação e não pode ser alterado posteriormente.
8. As matrizes em Java podem ter qualquer número de dimensões, embora as matrizes de duas dimensões sejam as mais comumente utilizadas.
9. Em uma matriz em Java, os elementos são acessados utilizando múltiplos índices, um para cada dimensão da matriz.
10. É possível definir matrizes em Java de forma literal, especificando seus elementos diretamente entre chaves e separados por vírgulas.

3. Subtópico:
3. Listas ligadas (LinkedList) em Java
Assertivas:
1. A LinkedList em Java é uma implementação da interface List que armazena elementos em uma estrutura de lista ligada.
2. A LinkedList em Java implementa a inserção de elementos de forma eficiente, uma vez que não é necessário reorganizar a estrutura.
3. A LinkedList em Java pode armazenar elementos de qualquer tipo por meio do uso de generics.
4. A LinkedList em Java permite a adição e remoção de elementos em qualquer posição da lista.
5. A LinkedList em Java não possui um tamanho fixo, o que significa que pode crescer ou encolher dinamicamente.
6. A LinkedList em Java permite o acesso rápido ao primeiro e ao último elemento da lista.
7. A LinkedList em Java é mais eficiente em termos de memória em comparação com outras implementações de lista, como o ArrayList.
8. A LinkedList em Java pode ser usada para implementar estruturas de dados complexas, como pilhas e filas.
9. A LinkedList em Java não é adequada para aplicações que exigem acesso aleatório aos elementos, pois o acesso sequencial é mais eficiente.
10. A LinkedList em Java é uma alternativa viável quando é necessário inserir ou remover elementos com frequência, mesmo que a velocidade de acesso seja menor.

4. Subtópico:
4. Pilhas (Stacks) e Filas (Queues) em Java
Assertivas:
1. As pilhas (stacks) em Java seguem o conceito de Last In, First Out (LIFO), ou seja, o último elemento adicionado é o primeiro a ser removido.
2. As filas (queues) em Java seguem o conceito de First In, First Out (FIFO), ou seja, o primeiro elemento adicionado é o primeiro a ser removido.
3. Em Java, as pilhas (stacks) são implementadas pela classe Stack.
4. Em Java, as filas (queues) são implementadas pelas classes Queue e Deque.
5. As pilhas (stacks) em Java podem ser utilizadas para inverter a ordem dos elementos de uma coleção.
6. As filas (queues) em Java podem ser utilizadas para armazenar dados em uma ordem sequencial.
7. Em uma pilha (stack) em Java, é possível empilhar e desempilhar elementos utilizando os métodos push() e pop(), respectivamente.
8. Em uma fila (queue) em Java, é possível adicionar elementos ao final da fila utilizando o método offer() e remover elementos do início da fila utilizando o método poll().
9. As pilhas (stacks) em Java possuem um método chamado peek() que permite visualizar o elemento do topo da pilha, sem removê-lo.
10. As filas (queues) em Java possuem um método chamado peek() que permite visualizar o elemento do início da fila, sem removê-lo.

5. Subtópico:
5. Conjuntos (Sets) e Mapas (Maps) em Java
Assertivas:
1. Em Java, o conjunto (set) não permite elementos duplicados, garantindo assim a unicidade dos elementos inseridos.
2. O mapa (map) em Java associa chaves a valores, permitindo acesso rápido aos valores com base nas chaves correspondentes.
3. Na estrutura de dados set em Java, a ordem dos elementos não é garantida, pois depende da implementação específica utilizada.
4. O mapa (map) em Java não permite que chaves duplicadas sejam adicionadas, substituindo o valor associado à chave anterior.
5. A classe HashSet em Java implementa a interface Set e utiliza internamente uma tabela hash para armazenar os elementos, garantindo uma inserção e busca eficientes.
6. A interface Map em Java é implementada pelas classes HashMap, TreeMap e LinkedHashMap, que fornecem diferentes implementações de mapas.
7. A classe HashMap em Java permite que nulos sejam usados como chaves e valores.
8. Ao iterar sobre um conjunto (set) em Java, a ordem dos elementos pode variar a cada iteração, pois depende da implementação utilizada.
9. A classe TreeMap em Java implementa a interface SortedMap, o que garante que os elementos sejam ordenados de acordo com a ordem natural das chaves ou um comparador fornecido.
10. O método size() em uma estrutura de dados set ou map em Java retorna o número de elementos atualmente armazenados na estrutura.

6. Subtópico:
6. Árvores binárias e suas implementações em Java 
Assertivas:
1. A árvore binária é uma estrutura de dados composta por nós, onde cada nó possui no máximo dois filhos.
2. A árvore binária possuirá pelo menos um nó, chamado de raiz.
3. Em uma árvore binária, o nó filho à esquerda é chamado de filho esquerdo e o nó filho à direita é chamado de filho direito.
4. As árvores binárias podem ser percorridas de três formas diferentes: pré-ordem, in-ordem e pós-ordem.
5. Em uma implementação de árvore binária em Java, é necessário criar uma classe para representar o nó, contendo os atributos do nó e métodos para manipulá-los.
6. A classe que representa a árvore binária em Java deve conter referências para os nós filhos esquerdo e direito, além de métodos para inserir, remover e buscar elementos.
7. A árvore binária de busca é uma variação da árvore binária, onde há uma restrição de ordenação dos elementos entre os nós.
8. Em uma árvore binária de busca, o nó à esquerda é sempre menor que o nó pai, e o nó à direita é sempre maior.
9. A implementação de uma árvore binária de busca em Java deve garantir a ordenação dos elementos durante a inserção e remoção de nós.
10. O tempo de busca em uma árvore binária pode variar de O(log n) até O(n), dependendo da estrutura da árvore.

7. Subtópico:
7. Tabelas Hashing e sua aplicação na linguagem Java 
Assertivas:
1. A tabela Hashing é uma estrutura de dados que armazena elementos de forma eficiente e permite acesso rápido a eles.
2. Na linguagem Java, as tabelas Hashing são implementadas pela classe HashMap, que segue a lógica de chave-valor.
3. A tabela Hashing utiliza uma função de dispersão para calcular o índice onde cada elemento será armazenado.
4. A função de dispersão deve ser bem projetada para minimizar colisões, ou seja, quando dois elementos são mapeados para o mesmo índice.
5. Em Java, a função hashCode() é usada para calcular o valor de dispersão de um objeto.
6. Caso ocorra uma colisão, os elementos são armazenados em uma lista encadeada dentro do mesmo índice, mantendo uma estrutura conhecida como "encadeamento separado" ou "resolução de colisão por lista encadeada".
7. As tabelas Hashing são amplamente utilizadas em Java para implementar estruturas como conjuntos (Set) e mapas (Map).
8. A complexidade média das operações de busca, inserção e remoção em uma tabela Hashing é O(1).
9. É possível personalizar a função de dispersão, implementando o método hashCode() nas classes dos objetos a serem armazenados, tornando o cálculo mais específico para o contexto da aplicação.
10. A tabela Hashing é especialmente útil quando se precisa de acesso rápido a um grande número de elementos, como na busca de palavras em dicionários ou na análise de frequência de caracteres em texto.

8. Subtópico:
8. Manipulação de dados com Collections Framework 
Assertivas:
1. A manipulação de dados com Collections Framework envolve a utilização de classes como ArrayList, HashSet e HashMap.
2. Collections Framework é uma biblioteca do Java que fornece implementações de estruturas de dados populares.
3. A manipulação de dados com Collections Framework permite adicionar, remover e pesquisar elementos em estruturas de dados de forma eficiente.
4. O uso de Collections Framework simplifica o trabalho com conjuntos de dados, uma vez que oferece métodos prontos para manipulação.
5. A manipulação de dados com Collections Framework é fundamental para resolver problemas complexos de manipulação e processamento de informações.
6. É possível ordenar os elementos de uma estrutura de dados utilizando métodos da Collections Framework, como o método sort.
7. A manipulação de dados com Collections Framework é amplamente utilizado no desenvolvimento de aplicações Java.
8. A manipulação de dados com Collections Framework facilita a reutilização de código, uma vez que oferece implementações prontas de estruturas de dados.
9. Collections Framework pode ser utilizado em qualquer tipo de projeto, independentemente do tamanho ou complexidade.
10. Dominar a manipulação de dados com Collections Framework é uma habilidade fundamental para programadores Java.

9. Subtópico:
9. Comparação entre diferentes tipos de estruturas de dados 
Assertivas:
1. Pilhas são estruturas de dados que seguem o princípio LIFO (último a entrar, primeiro a sair), enquanto filas seguem o princípio FIFO (primeiro a entrar, primeiro a sair).
2. Listas ligadas são estruturas de dados dinâmicas que permitem a inserção e remoção eficientes de elementos em qualquer posição.
3. Árvores são estruturas de dados hierárquicas que podem ser utilizadas para representar relações de parentesco, hierarquias de categorias, entre outros.
4. Grafos são estruturas de dados que modelam relações entre objetos e são compostos por vértices e arestas.
5. Tabelas de dispersão (hash tables) são estruturas de dados que associam chaves a valores por meio de uma função de dispersão, permitindo a busca rápida de elementos.
6. Filas de prioridade são estruturas de dados que armazenam elementos com uma prioridade associada, permitindo a recuperação do elemento de maior (ou menor) prioridade de forma eficiente.
7. Árvores binárias de busca são estruturas de dados que permitem busca de elementos de forma eficiente, mantendo os elementos ordenados.
8. Heaps são estruturas de dados que mantêm a propriedade de heap (o elemento de maior prioridade está sempre na raiz) e são usados para implementar filas de prioridade.
9. Árvores balanceadas, como as árvores AVL e as árvores rubro-negras, são estruturas de dados que garantem um balanceamento adequado, mantendo a altura da árvore logarítmica em relação ao número de elementos.
10. Gráficos de dispersão (scatter plots) não são estruturas de dados propriamente ditas, mas são gráficos utilizados para representar a relação entre duas variáveis numéricas.

10. Subtópico:
10. Melhores práticas para a utilização eficiente das estruturas de dados
Assertivas:
1. A utilização eficiente das estruturas de dados é fundamental para otimizar a performance e a utilização de recursos em um sistema.
2. A escolha correta da estrutura de dados adequada para cada cenário é um dos principais aspectos das melhores práticas de programação.
3. A utilização de estruturas de dados eficientes contribui para reduzir o consumo de memória, resultando em aplicações mais escaláveis.
4. A implementação correta das estruturas de dados, seguindo os princípios de orientação a objetos, é um fator crucial para a qualidade do código produzido.
5. Algoritmos de ordenação e busca são exemplos de operações que se beneficiam de uma estrutura de dados bem escolhida e implementada.
6. A utilização de estruturas de dados como pilhas, filas e listas encadeadas é recomendada quando é necessário realizar operações de inserção e remoção de elementos de forma eficiente.
7. Para operações de busca rápida em um conjunto de dados, a utilização de estruturas como árvores binárias de busca ou hash tables é apropriada.
8. A utilização de estruturas de dados balanceadas, como árvores AVL ou árvores B, é indicada para manter a eficiência de operações de busca, mesmo em casos de inserção e remoção frequentes.
9. O conhecimento das complexidades de tempo e espaço das operações realizadas em cada estrutura de dados é essencial para fazer a escolha adequada.
10. As melhores práticas para a utilização eficiente das estruturas de dados incluem o uso de algoritmos e técnicas que permitam a reutilização mínima de memória e a minimização da complexidade dos algoritmos implementados.


